# Архитектура и стандарты кода для «Chalk and Steel»

## 1. Требования к коду (MUST HAVE)

### Стиль и соглашения
*   **Язык**: C# 9-10.
*   **Именование**:
    *   `PascalCase`: классы, методы, свойства, публичные поля, интерфейсы (с префиксом `I`).
    *   `camelCase`: приватные поля, параметры методов.
*   **Зависимости**: Все зависимости класса передаются через конструктор и сохраняются в приватных полях только для чтения (`private readonly`).
*   **Интерфейсы**: Для всех менеджеров, сервисов и ключевых компонентов сначала создается интерфейс (например, `IInventoryManager`), затем его реализация.
*   **События**: Межмодульное взаимодействие через `IEventBus`. События — иммутабельные классы (`record` или `class` с get-свойствами), имена заканчиваются на `Event` (напр., `PlayerHealthChangedEvent`).
*   **Принцип единственной ответственности**: Класс решает одну задачу. Логика делится на мелкие, тестируемые методы.
*   **Null-безопасность**: Использование `?`, `??`, `ArgumentNullException.ThrowIfNull()`.
*   **Комментарии**: XML-документация (`///`) для публичных API. Минимум комментариев внутри методов.

### Тестируемость
*   Бизнес-логика (Pure C#) отделена от Unity (`MonoBehaviour`).
*   Классы допускают простое внедрение заглушек (mock) для зависимостей.

## 2. Архитектура проекта

Многослойная архитектура с чётким разделением ответственности.

### Слои (сверху вниз)

| Слой | Описание | Технологии | Ответственность |
| :--- | :--- | :--- | :--- |
| **1. Глобальные модули** | Фундаментальные системы, не зависящие от игровой логики. | Pure C# | `EventBus`, `GameStateMachine`, `ConfigProvider`. |
| **2. Менеджеры** | Ядро игровой логики и управление состояниями. | Pure C# | `PlayerManager`, `RoomManager`, `ProgressManager`. Обрабатывают данные, правила, прогресс. |
| **3. Обработчики** | Связующий слой между логикой и движком/представлением. | `MonoBehaviour` | `SystemHandlers`, `ViewHandlers`. Слушают события, вызывают методы Unity. |
| **4. Представление** | Визуальная часть и взаимодействие с игроком. | Unity GameObject, UI | UI компоненты, контроллеры игровых объектов. Отображают состояние, обрабатывают ввод. |

### Ключевые принципы
*   **Инъекция зависимостей через VContainer**: Все зависимости передаются через конструктор.
*   **Событийная связность**: Модули общаются через `EventBus`, что обеспечивает слабую связность.
*   **Зависимость от абстракций**: Менеджеры работают с интерфейсами, а не с конкретными реализациями.

### Поток данных
## 3. Основные модули системы
1.  **`EventBus` / `IEventBus`** - Центральная шина событий для связи между модулями.
2.  **`GameStateMachine` / `IGameStateMachine`** - Управление состояниями игры (Меню, Геймплей, Пауза, Экран смерти).
3.  **`PlayerManager` / `IPlayerManager`** - Управление состоянием игрока (здоровье, форма "Закалки", инвентарь).
4.  **`RoomManager` / `IRoomManager`** - Генерация и управление процедурными комнатами 9x9.
5.  **`ProgressManager` / `IProgressManager`** - Отслеживание смертей/убийств, управление сменой форм (Ребёнок/Подросток/Взрослый) и расчет концовок.

## 4. Масштабируемость и поддержка
*   **Новые механики**: Добавляются через подписку/публикацию событий в `EventBus` без изменения существующих модулей.
*   **Кроссплатформенность**: Для портирования на Nintendo Switch потребуется замена только слоя ввода (`InputHandler`).
*   **Расширение контента**: Новые концовки и формы добавляются в `ProgressManager` без изменений в архитектуре.